1、MODULE 宏定义 (具体可看 01_hello_world 的代码)
(linux-4.1.15-elf/work/src/linux-4.1.15/Makefile)

如果想在 Makefile 文件中使用宏的条件编译，可以使用下面两个宏：
    KBUILD_CFLAGS_KERNEL: 如果是编译进 kernel
    KBUILD_CFLAGS_MODULE  := -DMODULE 如果是模块则使用的是这个宏

============================================================
    KBUILD_AFLAGS_KERNEL :=
    KBUILD_CFLAGS_KERNEL :=  # 将驱动编译进 kernel 用的这个宏，这里没有定义，所以 if MODULE 为假，ifndef MODULE 为真
    KBUILD_AFLAGS   := -D__ASSEMBLY__
    KBUILD_AFLAGS_MODULE  := -DMODULE
    KBUILD_CFLAGS_MODULE  := -DMODULE # 如果是模块则使用的是这个宏
=================================================================

2、module_init 调用流程

#define module_init(x)	__initcall(x);
    #define __initcall(fn) device_initcall(fn)
        #define device_initcall(fn)		__define_initcall(fn, 6)
            #define __define_initcall(fn, id) \
                static initcall_t __initcall_##fn##id __used \
                __attribute__((__section__(".initcall" #id ".init"))) = fn; \
                LTO_REFERENCE_INITCALL(__initcall_##fn##id)

==》
    static initcall_t __initcall_hello_world6 __used __attribute__((__section__(".initcall6.init"))) = hello_world; 
解释：将 __initcall_hello_world6 初始化为 hello_world ，并将其放入 .initcall6.init 段中

===============================================================================

3、.initcall6.init 段定义在哪里？
linux-5.4.239/include/asm-generic/vmlinux.lds.h

如下宏定义：
#define INIT_CALLS_LEVEL(level)						\
		__initcall##level##_start = .;				\
		KEEP(*(.initcall##level##.init))			\
		KEEP(*(.initcall##level##s.init))			\

#define INIT_CALLS							\
		__initcall_start = .;					\
		KEEP(*(.initcallearly.init))				\
		INIT_CALLS_LEVEL(0)					\
		INIT_CALLS_LEVEL(1)					\
		INIT_CALLS_LEVEL(2)					\
		INIT_CALLS_LEVEL(3)					\
		INIT_CALLS_LEVEL(4)					\
		INIT_CALLS_LEVEL(5)					\
		INIT_CALLS_LEVEL(rootfs)				\
		INIT_CALLS_LEVEL(6)					\
		INIT_CALLS_LEVEL(7)					\
		__initcall_end = .;

这里的 0-7 表示的是优先级，即数字越小，系统启动后越先被调用
INIT_CALLS_LEVEL 会展开成两个段 (.initcall6.init/.initcall6s.init),不带“s”的段优先被加载
所以 .initcall6.init 段的初始化流程为：
    INIT_DATA_SECTION   (linux-5.4.239/arch/arm/kernel/vmlinux.lds.S)
        INIT_CALLS      (linux-5.4.239/include/asm-generic/vmlinux.lds.h)
            INIT_CALLS_LEVEL(6)
                #define INIT_CALLS_LEVEL(level)						\
                        __initcall##level##_start = .;				\
                        KEEP(*(.initcall##level##.init))			\
                        KEEP(*(.initcall##level##s.init))			\

这样就成功初始化了一个段，通过 module_init 修饰的函数就回被放到对应的段中。

==============================================================================================

4、那初始化的这些函数什么时候会被调用？

打开 linux-5.4.239/init/main.c 文件，能看到下面的代码段：
    extern initcall_entry_t __initcall_start[];
    extern initcall_entry_t __initcall0_start[];
    extern initcall_entry_t __initcall1_start[];
    extern initcall_entry_t __initcall2_start[];
    extern initcall_entry_t __initcall3_start[];
    extern initcall_entry_t __initcall4_start[];
    extern initcall_entry_t __initcall5_start[];
    extern initcall_entry_t __initcall6_start[];
    extern initcall_entry_t __initcall7_start[];
    extern initcall_entry_t __initcall_end[];

    static initcall_entry_t *initcall_levels[] __initdata = {
        __initcall0_start,
        __initcall1_start,
        __initcall2_start,
        __initcall3_start,
        __initcall4_start,
        __initcall5_start,
        __initcall6_start,
        __initcall7_start,
        __initcall_end,
    };

__initcall6_start 里面放的就是 hello_world 函数，并且将其放入了 .initcall6.init 段中

======================================================================================
调用流程如下：

start_kernel (linux-5.4.239/init/main.c)
    arch_call_rest_init
        rest_init
            kernel_init
                kernel_init_freeable
                    do_basic_setup
                        do_initcalls

===》
static void __init do_initcalls(void)
{
	int level;

	for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++)
		do_initcall_level(level);
}
根据不同的优先级进行遍历 initcall_levels 数组

===》
static void __init do_initcall_level(int level)
{
	initcall_entry_t *fn;

	strcpy(initcall_command_line, saved_command_line);
	parse_args(initcall_level_names[level],
		   initcall_command_line, __start___param,
		   __stop___param - __start___param,
		   level, level,
		   NULL, &repair_env_string);

	trace_initcall_level(initcall_level_names[level]);
	for (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++)
		do_one_initcall(initcall_from_entry(fn));
}
比如优先级为6，则 do_initcall_level(6) 则会依次遍历优先级为6的所有驱动函数，并调用 do_one_initcall 函数

===》
int __init_or_module do_one_initcall(initcall_t fn)
{
    ......
	do_trace_initcall_start(fn);
	ret = fn();
	do_trace_initcall_finish(fn, ret);
    ......
	return ret;
}

do_one_initcall 函数主要就是执行具体驱动函数了，比如 hello_world 函数就是在这里被调用的